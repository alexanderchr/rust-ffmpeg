#[crate_id = "avfilter#3"];
#[license = "MIT"];
#[crate_type = "lib"];
/* automatically generated by rust-bindgen */
extern mod avutil;
use std::libc::{c_void,c_int,c_uint,c_schar,uint8_t,int64_t,uint64_t,int8_t};

pub type __int128_t = c_void;
pub type __uint128_t = c_void;
pub type __builtin_va_list = [__va_list_tag, ..1u];
pub type AVFilterContext = Struct_AVFilterContext;
pub type AVFilterLink = Struct_AVFilterLink;
pub type AVFilterPad = Struct_AVFilterPad;
pub type Struct_AVFilterFormats = c_void;
pub type AVFilterFormats = Struct_AVFilterFormats;
pub struct Struct_AVFilterBuffer {
    data: [*mut uint8_t, ..8u],
    extended_data: *mut *mut uint8_t,
    linesize: [c_int, ..8u],
    _priv: *mut c_void,
    free: extern "C" fn(arg1: *mut Struct_AVFilterBuffer),
    format: c_int,
    w: c_int,
    h: c_int,
    refcount: c_uint,
}
pub type AVFilterBuffer = Struct_AVFilterBuffer;
pub struct Struct_AVFilterBufferRefAudioProps {
    channel_layout: uint64_t,
    nb_samples: c_int,
    sample_rate: c_int,
    channels: c_int,
}
pub type AVFilterBufferRefAudioProps = Struct_AVFilterBufferRefAudioProps;
pub struct Struct_AVFilterBufferRefVideoProps {
    w: c_int,
    h: c_int,
    sample_aspect_ratio: avutil::AVRational,
    interlaced: c_int,
    top_field_first: c_int,
    pict_type: avutil::Enum_AVPictureType,
    key_frame: c_int,
    qp_table_linesize: c_int,
    qp_table_size: c_int,
    qp_table: *mut int8_t,
}
pub type AVFilterBufferRefVideoProps = Struct_AVFilterBufferRefVideoProps;
pub struct Struct_AVFilterBufferRef {
    buf: *mut AVFilterBuffer,
    data: [*mut uint8_t, ..8u],
    extended_data: *mut *mut uint8_t,
    linesize: [c_int, ..8u],
    video: *mut AVFilterBufferRefVideoProps,
    audio: *mut AVFilterBufferRefAudioProps,
    pts: int64_t,
    pos: int64_t,
    format: c_int,
    perms: c_int,
    _type: avutil::Enum_AVMediaType,
    metadata: *mut avutil::AVDictionary,
}
pub type AVFilterBufferRef = Struct_AVFilterBufferRef;
pub struct Struct_AVFilterPad {
    name: *c_schar,
    _type: avutil::Enum_AVMediaType,
    min_perms: c_int,
    rej_perms: c_int,
    start_frame: extern "C" fn
                     (arg1: *mut AVFilterLink, arg2: *mut AVFilterBufferRef)
                     -> c_int,
    get_video_buffer: extern "C" fn
                          (arg1: *mut AVFilterLink, arg2: c_int, arg3: c_int,
                           arg4: c_int) -> *mut AVFilterBufferRef,
    get_audio_buffer: extern "C" fn
                          (arg1: *mut AVFilterLink, arg2: c_int, arg3: c_int)
                          -> *mut AVFilterBufferRef,
    end_frame: extern "C" fn(arg1: *mut AVFilterLink) -> c_int,
    draw_slice: extern "C" fn
                    (arg1: *mut AVFilterLink, arg2: c_int, arg3: c_int,
                     arg4: c_int) -> c_int,
    filter_frame: extern "C" fn
                      (arg1: *mut AVFilterLink, arg2: *mut AVFilterBufferRef)
                      -> c_int,
    poll_frame: extern "C" fn(arg1: *mut AVFilterLink) -> c_int,
    request_frame: extern "C" fn(arg1: *mut AVFilterLink) -> c_int,
    config_props: extern "C" fn(arg1: *mut AVFilterLink) -> c_int,
    needs_fifo: c_int,
}
pub struct Struct_AVFilter {
    name: *c_schar,
    description: *c_schar,
    inputs: *AVFilterPad,
    outputs: *AVFilterPad,
    init: extern "C" fn(arg1: *mut AVFilterContext, arg2: *c_schar) -> c_int,
    uninit: extern "C" fn(arg1: *mut AVFilterContext),
    query_formats: extern "C" fn(arg1: *mut AVFilterContext) -> c_int,
    priv_size: c_int,
    process_command: extern "C" fn
                         (arg1: *mut AVFilterContext, arg2: *c_schar,
                          arg3: *c_schar, arg4: *mut c_schar, arg5: c_int,
                          arg6: c_int) -> c_int,
    init_opaque: extern "C" fn
                     (arg1: *mut AVFilterContext, arg2: *c_schar,
                      arg3: *mut c_void) -> c_int,
    priv_class: *avutil::AVClass,
}
pub type AVFilter = Struct_AVFilter;
pub struct Struct_AVFilterContext {
    av_class: *avutil::AVClass,
    filter: *mut AVFilter,
    name: *mut c_schar,
    input_pads: *mut AVFilterPad,
    inputs: *mut *mut AVFilterLink,
    input_count: c_uint,
    nb_inputs: c_uint,
    output_pads: *mut AVFilterPad,
    outputs: *mut *mut AVFilterLink,
    output_count: c_uint,
    nb_outputs: c_uint,
    _priv: *mut c_void,
    command_queue: *mut Struct_AVFilterCommand,
}
pub type Struct_AVFilterCommand = c_void;
pub struct Struct_AVFilterLink {
    src: *mut AVFilterContext,
    srcpad: *mut AVFilterPad,
    dst: *mut AVFilterContext,
    dstpad: *mut AVFilterPad,
    _type: avutil::Enum_AVMediaType,
    w: c_int,
    h: c_int,
    sample_aspect_ratio: avutil::AVRational,
    channel_layout: uint64_t,
    sample_rate: c_int,
    format: c_int,
    time_base: avutil::AVRational,
    in_formats: *mut AVFilterFormats,
    out_formats: *mut AVFilterFormats,
    in_samplerates: *mut AVFilterFormats,
    out_samplerates: *mut AVFilterFormats,
    in_channel_layouts: *mut Struct_AVFilterChannelLayouts,
    out_channel_layouts: *mut Struct_AVFilterChannelLayouts,
    request_samples: c_int,
    init_state: Enum_Unnamed1,
    pool: *mut Struct_AVFilterPool,
    graph: *mut Struct_AVFilterGraph,
    current_pts: int64_t,
    age_index: c_int,
    frame_rate: avutil::AVRational,
    partial_buf: *mut AVFilterBufferRef,
    partial_buf_size: c_int,
    min_samples: c_int,
    max_samples: c_int,
    cur_buf_copy: *mut AVFilterBufferRef,
    closed: c_int,
    channels: c_int,
}
pub type Struct_AVFilterChannelLayouts = c_void;
pub type Enum_Unnamed1 = c_uint;
pub static AVLINK_UNINIT: c_uint = 0;
pub static AVLINK_STARTINIT: c_uint = 1;
pub static AVLINK_INIT: c_uint = 2;
pub type Struct_AVFilterPool = c_void;
pub type Struct_AVFilterGraph = c_void;
pub type __va_list_tag = Struct___va_list_tag;
pub struct Struct___va_list_tag {
    gp_offset: c_uint,
    fp_offset: c_uint,
    overflow_arg_area: *mut c_void,
    reg_save_area: *mut c_void,
}
#[link(name = "avfilter")]
extern "C" {
    pub fn avfilter_version() -> c_uint;
    pub fn avfilter_configuration() -> *c_schar;
    pub fn avfilter_license() -> *c_schar;
    pub fn avfilter_get_class() -> *avutil::AVClass;
    pub fn avfilter_copy_buffer_ref_props(dst: *mut AVFilterBufferRef,
                                          src: *mut AVFilterBufferRef);
    pub fn avfilter_ref_buffer(_ref: *mut AVFilterBufferRef, pmask: c_int) ->
     *mut AVFilterBufferRef;
    pub fn avfilter_unref_buffer(_ref: *mut AVFilterBufferRef);
    pub fn avfilter_unref_bufferp(_ref: *mut *mut AVFilterBufferRef);
    pub fn avfilter_ref_get_channels(_ref: *mut AVFilterBufferRef) -> c_int;
    pub fn avfilter_pad_get_name(pads: *mut AVFilterPad, pad_idx: c_int) ->
     *c_schar;
    pub fn avfilter_pad_get_type(pads: *mut AVFilterPad, pad_idx: c_int) ->
     avutil::Enum_AVMediaType;
    pub fn avfilter_link(src: *mut AVFilterContext, srcpad: c_uint,
                         dst: *mut AVFilterContext, dstpad: c_uint) -> c_int;
    pub fn avfilter_link_free(link: *mut *mut AVFilterLink);
    pub fn avfilter_link_get_channels(link: *mut AVFilterLink) -> c_int;
    pub fn avfilter_link_set_closed(link: *mut AVFilterLink, closed: c_int);
    pub fn avfilter_config_links(filter: *mut AVFilterContext) -> c_int;
    pub fn avfilter_get_video_buffer_ref_from_arrays(data:
                                                         [*mut uint8_t, ..4u],
                                                     linesize: [c_int, ..4u],
                                                     perms: c_int, w: c_int,
                                                     h: c_int,
                                                     format:
                                                         avutil::Enum_AVPixelFormat)
     -> *mut AVFilterBufferRef;
    pub fn avfilter_get_audio_buffer_ref_from_arrays(data: *mut *mut uint8_t,
                                                     linesize: c_int,
                                                     perms: c_int,
                                                     nb_samples: c_int,
                                                     sample_fmt:
                                                         avutil::Enum_AVSampleFormat,
                                                     channel_layout: uint64_t)
     -> *mut AVFilterBufferRef;
    pub fn avfilter_get_audio_buffer_ref_from_arrays_channels(data:
                                                                  *mut *mut uint8_t,
                                                              linesize: c_int,
                                                              perms: c_int,
                                                              nb_samples:
                                                                  c_int,
                                                              sample_fmt:
                                                                  avutil::Enum_AVSampleFormat,
                                                              channels: c_int,
                                                              channel_layout:
                                                                  uint64_t) ->
     *mut AVFilterBufferRef;
    pub fn avfilter_process_command(filter: *mut AVFilterContext,
                                    cmd: *c_schar, arg: *c_schar,
                                    res: *mut c_schar, res_len: c_int,
                                    flags: c_int) -> c_int;
    pub fn avfilter_register_all();
    pub fn avfilter_uninit();
    pub fn avfilter_register(filter: *mut AVFilter) -> c_int;
    pub fn avfilter_get_by_name(name: *c_schar) -> *mut AVFilter;
    pub fn av_filter_next(filter: *mut *mut AVFilter) -> *mut *mut AVFilter;
    pub fn avfilter_open(filter_ctx: *mut *mut AVFilterContext,
                         filter: *mut AVFilter, inst_name: *c_schar) -> c_int;
    pub fn avfilter_init_filter(filter: *mut AVFilterContext, args: *c_schar,
                                opaque: *mut c_void) -> c_int;
    pub fn avfilter_free(filter: *mut AVFilterContext);
    pub fn avfilter_insert_filter(link: *mut AVFilterLink,
                                  filt: *mut AVFilterContext,
                                  filt_srcpad_idx: c_uint,
                                  filt_dstpad_idx: c_uint) -> c_int;
}

pub fn version() -> uint{
    unsafe {
        avfilter_version() as uint
    }
}
pub fn license() -> ~str {
    unsafe {
        std::str::raw::from_c_str(avfilter_license())
    }
}
